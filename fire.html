<!doctype html>
<html lang="ru">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Unicode Flame — size min + coeff</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
</style>
<canvas id="c"></canvas>
<script>
/* ===================== ПАРАМЕТРЫ (МОЖНО МЕНЯТЬ) =====================

— СИМВОЛЫ —
const SYMBOLS     : «палитра» символов (3–12 штук)
const CELL        : размер «пикселя»-ячейки
const FG          : цвет символов
const CONTRAST    : мягкость переходов (1.0..2.0)

— ОСНОВАНИЕ/НАПРАВЛЕНИЕ —
BASE              : [x,y] основание пламени (0..1) — по умолчанию центр-низ
TIP               : [x,y] вершина (чуть по диагонали)
PATH_OFFSET       : контрольная точка квадр. Безье (задаёт «сгиб» пути)
BLOBS             : число эллипсов вдоль пути (3–7)

— РАЗМЕРЫ ЭЛЛИПСОВ (ВАЖНОЕ НОВОЕ) —
SIZE_MIN          : минимальный размер эллипса (доля ширины экрана)
SIZE_K            : коэффициент зависимости. 0 = все равны SIZE_MIN.
                    10 = самый верхний = 10 * SIZE_MIN,
                    промежуточные растут линейно от основания к верху.
SIZE_CURVE        : 1 = линейно; >1 — рост позже; <1 — раньше.
ROUNDNESS         : 0..1 — 1 ближе к кругу (округление формы)

— ДЫХАНИЕ —
SPEED             : скорость
BREATH_SIZE       : амплитуда дыхания размеров (0..0.45)
BREATH_TILT       : покачивание угла
BREATH_DRIFT      : дрейф центра

— СВЕТ/ВИНЬЕТКА —
SHIFT_GAIN        : сила диагонального подсвета в сторону TIP
VIGNETTE, VIGNETTE_POWER : виньетка

— ШУМ —
NOISE, NOISE_SPEED, JITTER: зерно и микродрожание
===================================================================== */

const SYMBOLS = ["·","˙","▏","▚","░","▜","▉","▉"];
const CELL = 10;
const FG = "#fff";
const CONTRAST = 1.2;

const BASE = [0.5, 0.94];
const TIP  = [0.62, 0.2];
const PATH_OFFSET = [0.56, 0.55];
const BLOBS = 6;

// ---- размеры эллипсов ----
const SIZE_MIN   = 0.15;   // минимальный размер (например, 0.07 = 7% ширины)
const SIZE_K     = 2.6;      // коэффициент: 0 → все = SIZE_MIN; 6 → верхний = 6×SIZE_MIN
const SIZE_CURVE = 1.2;    // кривая роста: 1 линейно; 2 — рост к концу; 0.5 — в начале
const ROUNDNESS  = 0.6;    // 0..1 — округлить эллипсы (1 ≈ круги)

const SPEED = 0.22;
const BREATH_SIZE = 0.28;
const BREATH_TILT = 0.12;
const BREATH_DRIFT = 0.020;

const SHIFT_GAIN = 0.65;
const VIGNETTE = 0.4;
const VIGNETTE_POWER = 0.2;

const NOISE = 0.16, NOISE_SPEED = 0.25, JITTER = 0.25;

/* ===================== КОД НИЖЕ ЛУЧШЕ НЕ ТРОГАТЬ ==================== */

const cv = document.getElementById('c');
const ctx = cv.getContext('2d');
let W,H,cols,rows,px;

function resize(){
  const dpr = Math.max(1, devicePixelRatio||1);
  W = Math.floor(innerWidth*dpr); H = Math.floor(innerHeight*dpr);
  cv.width=W; cv.height=H; cv.style.width=innerWidth+'px'; cv.style.height=innerHeight+'px';
  px = CELL*dpr; cols=Math.ceil(W/px); rows=Math.ceil(H/px);
  ctx.font = `${Math.floor(px)}px monospace`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
}
addEventListener('resize', resize, {passive:true}); resize();

function bezier2(a,b,c,t){ const u=1-t; return [u*u*a[0]+2*u*t*b[0]+t*t*c[0], u*u*a[1]+2*u*t*b[1]+t*t*c[1]]; }

// создаём BLOBS эллипсов вдоль BASE→TIP
const blobs = Array.from({length:BLOBS}, (_,i)=>{
const t0 = BLOBS===1 ? 0.5 : i/(BLOBS-1);
const t  = Math.pow(t0, SIZE_CURVE);   // 0..1 вдоль пути (снизу→вверх)
const g  = 1 - t;                       // инверсия: крупнее у основания, меньше кверху
  const [x,y] = bezier2(BASE, PATH_OFFSET, TIP, t0);

  // линейный рост: min → min*SIZE_K
const baseSize = SIZE_MIN * (1 + (SIZE_K - 1) * g);  const rx = baseSize;                               // полуось по X
  const ry = baseSize * (1 - (1-ROUNDNESS)*0.6);     // полуось по Y (округляем форму)

  return {
    x,y,
    rx, ry,
    ang: -0.6 + (Math.random()-0.5)*0.2,             // слегка по диагонали
    phase: Math.random()*Math.PI*2
  };
});

function rot(x,y,a){ const c=Math.cos(a), s=Math.sin(a); return [c*x - s*y, s*x + c*y]; }

function field(xn, yn, t){
  let s=0;
  for(const b of blobs){
    const kx = 1 + BREATH_SIZE*Math.sin(t*SPEED*1.00 + b.phase);
    const ky = 1 + BREATH_SIZE*Math.cos(t*SPEED*1.12 + b.phase*1.1);
    const a  = b.ang + BREATH_TILT*Math.sin(t*SPEED*0.7 + b.phase*0.8);

    const cx = b.x + BREATH_DRIFT*Math.sin(t*0.9 + b.phase);
    const cy = b.y + BREATH_DRIFT*Math.cos(t*0.8 + b.phase);

    const [ux,uy] = rot(xn-cx, yn-cy, a);
    const d = (ux*ux)/(b.rx*b.rx*kx*kx) + (uy*uy)/(b.ry*b.ry*ky*ky);
    s += Math.exp(-3*d);
  }

  // диагональный подсвет к TIP
  const diag = Math.max(0, (xn*TIP[0] + yn*TIP[1]) / Math.hypot(TIP[0], TIP[1]));
  s += diag*SHIFT_GAIN;

  // виньетка
  const dx=xn-0.5, dy=yn-0.5;
  const r = Math.hypot(dx*1.2, dy*1.2);
  const vig = 1 - VIGNETTE*Math.pow(Math.min(1,r), VIGNETTE_POWER);
  s = Math.max(0, s*vig);

  return Math.pow(Math.min(1, s), CONTRAST);
}

// дешёвый шум
function hash(i,j,k=0){ let n=(i*73856093)^(j*19349663)^(k*83492791); n=(n<<13)^n; return ((n*(n*n*15731+789221)+1376312589)>>>0)/4294967295; }

function draw(tms){
  const t=tms/1000;
  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
  ctx.fillStyle=FG;
  const kt=Math.floor(t*NOISE_SPEED*60);

  for(let j=0;j<rows;j++){
    const y0=(j+0.5)*px, yn=y0/H;
    for(let i=0;i<cols;i++){
      const x0=(i+0.5)*px, xn=x0/W;

      let v = field(xn,yn,t);
      v = Math.min(1, Math.max(0, v + (hash(i,j,kt)*2-1)*NOISE));

      const idx = Math.min(SYMBOLS.length-1, Math.floor(v*SYMBOLS.length));
      const a = 0.5 + 0.5*v;

      const jx=(hash(j,i,kt+7)-0.5)*JITTER*px;
      const jy=(hash(i,j,kt+13)-0.5)*JITTER*px;

      ctx.globalAlpha=a; ctx.fillText(SYMBOLS[idx], x0+jx, y0+jy);
    }
  }
  ctx.globalAlpha=1; requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</html>
